
\section{Schedule} 


\parskip = 0pt


\noindent This section lists all the variables which are assigned storage by thorn WVUThorns/Baikal.  Storage can either last for the duration of the run ({\bf Always} means that if this thorn is activated storage will be assigned, {\bf Conditional} means that if this thorn is activated storage will be assigned for the duration of the run if some condition is met), or can be turned on for the duration of a schedule function.


\subsection*{Storage}

\hspace{5mm}

 \begin{tabular*}{160mm}{ll} 

{\bf Always:}&  ~ \\ 
 evol\_variables[3] & ~\\ 
 evol\_variables\_rhs[1] & ~\\ 
 auxevol\_variables[1] & ~\\ 
 aux\_variables[3] & ~\\ 
~ & ~\\ 
\end{tabular*} 


\subsection*{Scheduled Functions}
\vspace{5mm}

\noindent {\bf CCTK\_STARTUP} 

\hspace{5mm} baikal\_registerslicing 

\hspace{5mm}{\it register 3+1 slicing condition } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & Language:  & c \\ 
~ & Options:  & meta \\ 
~ & Type:  & function \\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf Driver\_BoundarySelect}   (conditional) 

\hspace{5mm} baikal\_specify\_driver\_boundaryconditions 

\hspace{5mm}{\it register boundary conditions in presync bin driver\_boundaryselect. } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & Language:  & c \\ 
~ & Options:  & meta \\ 
~ & Type:  & function \\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf MoL\_CalcRHS}   (conditional) 

\hspace{5mm} baikal\_rhs\_eval\_order\_2 

\hspace{5mm}{\it evaluate bssn rhss, at finite-differencing order 2 } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & After:  & baikal\_ricci \\ 
~ & Language:  & c \\ 
~ & Reads:  & evol\_variables(everywhere) \\ 
~& ~ &auxevol\_variables(interior)\\ 
~ & Type:  & function \\ 
~ & Writes:  & evol\_variables\_rhs(interior) \\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf MoL\_CalcRHS}   (conditional) 

\hspace{5mm} baikal\_rhs\_eval\_order\_4 

\hspace{5mm}{\it evaluate bssn rhss, at finite-differencing order 4 } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & After:  & baikal\_ricci \\ 
~ & Language:  & c \\ 
~ & Reads:  & evol\_variables(everywhere) \\ 
~& ~ &auxevol\_variables(interior)\\ 
~ & Type:  & function \\ 
~ & Writes:  & evol\_variables\_rhs(interior) \\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf MoL\_CalcRHS}   (conditional) 

\hspace{5mm} baikal\_specify\_newrad\_boundaryconditions\_parameters 

\hspace{5mm}{\it newrad boundary conditions, scheduled right after rhs eval. } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & After:  & baikal\_rhs \\ 
~ & Language:  & c \\ 
~ & Reads:  & evol\_variables(everywhere) \\ 
~ & Type:  & function \\ 
~ & Writes:  & evol\_variables\_rhs(boundary) \\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf MoL\_PostStep}   (conditional) 

\hspace{5mm} baikal\_bssn\_to\_adm 

\hspace{5mm}{\it perform bssn-to-adm conversion. useful for diagnostics. } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & After:  & baikal\_evol\_applybcs \\ 
~ & Before:  & admbase\_setadmvars \\ 
~ & Language:  & c \\ 
~ & Reads:  & add00gf \\ 
~& ~ &add01gf\\ 
~& ~ &add02gf\\ 
~& ~ &add11gf\\ 
~& ~ &add12gf\\ 
~& ~ &add22gf\\ 
~& ~ &hdd00gf\\ 
~& ~ &hdd01gf\\ 
~& ~ &hdd02gf\\ 
~& ~ &hdd11gf\\ 
~& ~ &hdd12gf\\ 
~& ~ &hdd22gf\\ 
~& ~ &vetu0gf\\ 
~& ~ &vetu1gf\\ 
~& ~ &vetu2gf\\ 
~& ~ &betu0gf\\ 
~& ~ &betu1gf\\ 
~& ~ &betu2gf\\ 
~& ~ &cfgf\\ 
~& ~ &trkgf\\ 
~& ~ &alphagf\\ 
~ & Type:  & function \\ 
~ & Writes:  & admbase::metric(everywhere) \\ 
~& ~ &admbase::shift(everywhere)\\ 
~& ~ &admbase::curv(everywhere)\\ 
~& ~ &admbase::dtshift(everywhere)\\ 
~& ~ &admbase::lapse(everywhere)\\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf MoL\_PostStep}   (conditional) 

\hspace{5mm} baikal\_enforce\_detgammahat\_constraint 

\hspace{5mm}{\it enforce detgammabar = detgammahat (= 1 in cartesian) } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & Language:  & c \\ 
~ & Reads:  & hdd00gf \\ 
~& ~ &hdd01gf\\ 
~& ~ &hdd02gf\\ 
~& ~ &hdd11gf\\ 
~& ~ &hdd12gf\\ 
~& ~ &hdd22gf\\ 
~ & Type:  & function \\ 
~ & Writes:  & hdd00gf(everywhere) \\ 
~& ~ &hdd01gf(everywhere)\\ 
~& ~ &hdd02gf(everywhere)\\ 
~& ~ &hdd11gf(everywhere)\\ 
~& ~ &hdd12gf(everywhere)\\ 
~& ~ &hdd22gf(everywhere)\\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf MoL\_PostStep}   (conditional) 

\hspace{5mm} baikal\_floor\_the\_lapse 

\hspace{5mm}{\it set lapse = max(lapse\_floor, lapse) } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & Before:  & baikal\_enforce\_detgammahat\_constraint \\ 
~ & Language:  & c \\ 
~ & Reads:  & alphagf(everywhere) \\ 
~ & Type:  & function \\ 
~ & Writes:  & alphagf(everywhere) \\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf MoL\_PostStep}   (conditional) 

\hspace{5mm} baikal\_specify\_evol\_boundaryconditions 

\hspace{5mm}{\it register boundary conditions and perform amr+interprocessor synchronization } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & Language:  & c \\ 
~ & Options:  & level \\ 
~ & Sync:  & evol\_variables \\ 
~ & Type:  & function \\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf MoL\_PostStep}   (conditional) 

\hspace{5mm} applybcs 

\hspace{5mm}{\it apply registered boundary conditions } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & After:  & baikal\_specify\_evol\_boundaryconditions \\ 
~ & Type:  & group \\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf MoL\_PseudoEvolution}   (conditional) 

\hspace{5mm} baikal\_bssn\_constraints\_order\_2 

\hspace{5mm}{\it compute bssn (hamiltonian and momentum) constraints, at finite-differencing order 2 } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & Language:  & c \\ 
~ & Reads:  & add00gf \\ 
~& ~ &add01gf\\ 
~& ~ &add02gf\\ 
~& ~ &add11gf\\ 
~& ~ &add12gf\\ 
~& ~ &add22gf\\ 
~& ~ &hdd00gf\\ 
~& ~ &hdd01gf\\ 
~& ~ &hdd02gf\\ 
~& ~ &hdd11gf\\ 
~& ~ &hdd12gf\\ 
~& ~ &hdd22gf\\ 
~& ~ &trkgf\\ 
~& ~ &cfgf\\ 
~& ~ &lambdau0gf\\ 
~& ~ &lambdau1gf\\ 
~& ~ &lambdau2gf\\ 
~& ~ &alphagf\\ 
~& ~ &vetu0gf\\ 
~& ~ &vetu1gf\\ 
~& ~ &vetu2gf\\ 
~& ~ &t4uu00gf\\ 
~& ~ &t4uu01gf\\ 
~& ~ &t4uu02gf\\ 
~& ~ &t4uu03gf\\ 
~ & Type:  & function \\ 
~ & Writes:  & aux\_variables \\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf MoL\_PseudoEvolution}   (conditional) 

\hspace{5mm} baikal\_bssn\_constraints\_order\_4 

\hspace{5mm}{\it compute bssn (hamiltonian and momentum) constraints, at finite-differencing order 4 } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & Language:  & c \\ 
~ & Reads:  & add00gf \\ 
~& ~ &add01gf\\ 
~& ~ &add02gf\\ 
~& ~ &add11gf\\ 
~& ~ &add12gf\\ 
~& ~ &add22gf\\ 
~& ~ &hdd00gf\\ 
~& ~ &hdd01gf\\ 
~& ~ &hdd02gf\\ 
~& ~ &hdd11gf\\ 
~& ~ &hdd12gf\\ 
~& ~ &hdd22gf\\ 
~& ~ &trkgf\\ 
~& ~ &cfgf\\ 
~& ~ &lambdau0gf\\ 
~& ~ &lambdau1gf\\ 
~& ~ &lambdau2gf\\ 
~& ~ &alphagf\\ 
~& ~ &vetu0gf\\ 
~& ~ &vetu1gf\\ 
~& ~ &vetu2gf\\ 
~& ~ &t4uu00gf\\ 
~& ~ &t4uu01gf\\ 
~& ~ &t4uu02gf\\ 
~& ~ &t4uu03gf\\ 
~ & Type:  & function \\ 
~ & Writes:  & aux\_variables \\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf CCTK\_BASEGRID} 

\hspace{5mm} baikal\_symmetry\_registration\_oldcartgrid3d 

\hspace{5mm}{\it register symmetries, the cartgrid3d way. } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & Language:  & c \\ 
~ & Options:  & global \\ 
~ & Type:  & function \\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf MoL\_PseudoEvolution} 

\hspace{5mm} baikal\_bssn\_to\_adm 

\hspace{5mm}{\it perform bssn-to-adm conversion in mol\_pseudoevolution. needed for proper hydrobase integration. } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & After:  & baikal\_aux\_applybcs \\ 
~ & Language:  & c \\ 
~ & Reads:  & add00gf \\ 
~& ~ &add01gf\\ 
~& ~ &add02gf\\ 
~& ~ &add11gf\\ 
~& ~ &add12gf\\ 
~& ~ &add22gf\\ 
~& ~ &hdd00gf\\ 
~& ~ &hdd01gf\\ 
~& ~ &hdd02gf\\ 
~& ~ &hdd11gf\\ 
~& ~ &hdd12gf\\ 
~& ~ &hdd22gf\\ 
~& ~ &vetu0gf\\ 
~& ~ &vetu1gf\\ 
~& ~ &vetu2gf\\ 
~& ~ &betu0gf\\ 
~& ~ &betu1gf\\ 
~& ~ &betu2gf\\ 
~& ~ &cfgf\\ 
~& ~ &trkgf\\ 
~& ~ &alphagf\\ 
~ & Type:  & function \\ 
~ & Writes:  & admbase::metric(everywhere) \\ 
~& ~ &admbase::shift(everywhere)\\ 
~& ~ &admbase::curv(everywhere)\\ 
~& ~ &admbase::dtshift(everywhere)\\ 
~& ~ &admbase::lapse(everywhere)\\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf MoL\_PseudoEvolution} 

\hspace{5mm} baikal\_t4dd\_to\_t4uu 

\hspace{5mm}{\it compute t4uu from t4dd (provided in et?? from tmunubase), needed for bssn constraints } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & Before:  & baikal\_bssn\_constraints \\ 
~ & Language:  & c \\ 
~ & Reads:  & tmunubase::stress\_energy\_scalar \\ 
~& ~ &tmunubase::stress\_energy\_vector\\ 
~& ~ &tmunubase::stress\_energy\_tensor\\ 
~& ~ &hdd00gf\\ 
~& ~ &hdd01gf\\ 
~& ~ &hdd02gf\\ 
~& ~ &hdd11gf\\ 
~& ~ &hdd12gf\\ 
~& ~ &hdd22gf\\ 
~& ~ &alphagf\\ 
~& ~ &cfgf\\ 
~& ~ &vetu0gf\\ 
~& ~ &vetu1gf\\ 
~& ~ &vetu2gf\\ 
~ & Type:  & function \\ 
~ & Writes:  & t4uu00gf(everywhere) \\ 
~& ~ &t4uu01gf(everywhere)\\ 
~& ~ &t4uu02gf(everywhere)\\ 
~& ~ &t4uu03gf(everywhere)\\ 
~& ~ &t4uu11gf(everywhere)\\ 
~& ~ &t4uu12gf(everywhere)\\ 
~& ~ &t4uu13gf(everywhere)\\ 
~& ~ &t4uu22gf(everywhere)\\ 
~& ~ &t4uu23gf(everywhere)\\ 
~& ~ &t4uu33gf(everywhere)\\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf MoL\_PseudoEvolution} 

\hspace{5mm} baikal\_specify\_aux\_boundaryconditions 

\hspace{5mm}{\it register boundary conditions and perform amr+interprocessor synchronization } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & After:  & baikal\_bssn\_constraints \\ 
~ & Language:  & c \\ 
~ & Options:  & level \\ 
~ & Sync:  & aux\_variables \\ 
~ & Type:  & function \\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf MoL\_PseudoEvolution} 

\hspace{5mm} applybcs 

\hspace{5mm}{\it apply registered boundary conditions } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & After:  & baikal\_specify\_aux\_boundaryconditions \\ 
~ & Type:  & group \\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf CCTK\_BASEGRID} 

\hspace{5mm} baikal\_zero\_rhss 

\hspace{5mm}{\it idea from lean: set all rhs functions to zero to prevent spurious nans } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & After:  & symmetry\_registration \\ 
~ & Language:  & c \\ 
~ & Type:  & function \\ 
~ & Writes:  & evol\_variables\_rhs(everywhere) \\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf CCTK\_INITIAL}   (conditional) 

\hspace{5mm} baikal\_adm\_to\_bssn\_order\_2 

\hspace{5mm}{\it convert initial data into bssn variables } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & After:  & admbase\_postinitial \\ 
~ & Language:  & c \\ 
~ & Reads:  & admbase::metric \\ 
~& ~ &admbase::shift\\ 
~& ~ &admbase::curv\\ 
~& ~ &admbase::dtshift\\ 
~& ~ &admbase::lapse\\ 
~ & Sync:  & evol\_variables \\ 
~ & Type:  & function \\ 
~ & Writes:  & evol\_variables \\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf CCTK\_INITIAL}   (conditional) 

\hspace{5mm} baikal\_adm\_to\_bssn\_order\_4 

\hspace{5mm}{\it convert initial data into bssn variables } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & After:  & admbase\_postinitial \\ 
~ & Language:  & c \\ 
~ & Reads:  & admbase::metric \\ 
~& ~ &admbase::shift\\ 
~& ~ &admbase::curv\\ 
~& ~ &admbase::dtshift\\ 
~& ~ &admbase::lapse\\ 
~ & Sync:  & evol\_variables \\ 
~ & Type:  & function \\ 
~ & Writes:  & evol\_variables \\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf MoL\_Register}   (conditional) 

\hspace{5mm} baikal\_mol\_registration 

\hspace{5mm}{\it register variables for mol } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & Language:  & c \\ 
~ & Options:  & meta \\ 
~ & Type:  & function \\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf MoL\_CalcRHS}   (conditional) 

\hspace{5mm} baikal\_ricci\_eval\_order\_2 

\hspace{5mm}{\it compute ricci tensor, needed for bssn rhss, at finite-differencing order 2 } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & Before:  & baikal\_rhs \\ 
~ & Language:  & c \\ 
~ & Reads:  & hdd00gf \\ 
~& ~ &hdd01gf\\ 
~& ~ &hdd02gf\\ 
~& ~ &hdd11gf\\ 
~& ~ &hdd12gf\\ 
~& ~ &hdd22gf\\ 
~& ~ &lambdau0gf\\ 
~& ~ &lambdau1gf\\ 
~& ~ &lambdau2gf\\ 
~ & Type:  & function \\ 
~ & Writes:  & rbardd00gf \\ 
~& ~ &rbardd01gf\\ 
~& ~ &rbardd02gf\\ 
~& ~ &rbardd11gf\\ 
~& ~ &rbardd12gf\\ 
~& ~ &rbardd22gf\\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf MoL\_CalcRHS}   (conditional) 

\hspace{5mm} baikal\_ricci\_eval\_order\_4 

\hspace{5mm}{\it compute ricci tensor, needed for bssn rhss, at finite-differencing order 4 } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & Before:  & baikal\_rhs \\ 
~ & Language:  & c \\ 
~ & Reads:  & hdd00gf \\ 
~& ~ &hdd01gf\\ 
~& ~ &hdd02gf\\ 
~& ~ &hdd11gf\\ 
~& ~ &hdd12gf\\ 
~& ~ &hdd22gf\\ 
~& ~ &lambdau0gf\\ 
~& ~ &lambdau1gf\\ 
~& ~ &lambdau2gf\\ 
~ & Type:  & function \\ 
~ & Writes:  & rbardd00gf \\ 
~& ~ &rbardd01gf\\ 
~& ~ &rbardd02gf\\ 
~& ~ &rbardd11gf\\ 
~& ~ &rbardd12gf\\ 
~& ~ &rbardd22gf\\ 
\end{tabular*} 


\vspace{5mm}

\noindent {\bf MoL\_CalcRHS}   (conditional) 

\hspace{5mm} baikal\_t4dd\_to\_t4uu 

\hspace{5mm}{\it compute t4uu from t4dd (provided in et?? from tmunubase), needed for bssn rhss } 


\hspace{5mm}

 \begin{tabular*}{160mm}{cll} 
~ & Before:  & baikal\_rhs \\ 
~ & Language:  & c \\ 
~ & Reads:  & tmunubase::stress\_energy\_scalar \\ 
~& ~ &tmunubase::stress\_energy\_vector\\ 
~& ~ &tmunubase::stress\_energy\_tensor\\ 
~& ~ &hdd00gf\\ 
~& ~ &hdd01gf\\ 
~& ~ &hdd02gf\\ 
~& ~ &hdd11gf\\ 
~& ~ &hdd12gf\\ 
~& ~ &hdd22gf\\ 
~& ~ &alphagf\\ 
~& ~ &cfgf\\ 
~& ~ &vetu0gf\\ 
~& ~ &vetu1gf\\ 
~& ~ &vetu2gf\\ 
~ & Type:  & function \\ 
~ & Writes:  & t4uu00gf(everywhere) \\ 
~& ~ &t4uu01gf(everywhere)\\ 
~& ~ &t4uu02gf(everywhere)\\ 
~& ~ &t4uu03gf(everywhere)\\ 
~& ~ &t4uu11gf(everywhere)\\ 
~& ~ &t4uu12gf(everywhere)\\ 
~& ~ &t4uu13gf(everywhere)\\ 
~& ~ &t4uu22gf(everywhere)\\ 
~& ~ &t4uu23gf(everywhere)\\ 
~& ~ &t4uu33gf(everywhere)\\ 
\end{tabular*} 


\subsection*{Aliased Functions}

\hspace{5mm}

 \begin{tabular*}{160mm}{ll} 

{\bf Alias Name:} ~~~~~~~ & {\bf Function Name:} \\ 
ApplyBCs & Baikal\_aux\_ApplyBCs \\ 
Baikal\_BSSN\_constraints\_order\_2 & Baikal\_BSSN\_constraints \\ 
Baikal\_BSSN\_constraints\_order\_4 & Baikal\_BSSN\_constraints \\ 
Baikal\_Ricci\_eval\_order\_2 & Baikal\_Ricci \\ 
Baikal\_Ricci\_eval\_order\_4 & Baikal\_Ricci \\ 
Baikal\_Symmetry\_registration\_oldCartGrid3D & Symmetry\_registration \\ 
Baikal\_rhs\_eval\_order\_2 & Baikal\_RHS \\ 
Baikal\_rhs\_eval\_order\_4 & Baikal\_RHS \\ 
\end{tabular*} 



\vspace{5mm}\parskip = 10pt 
